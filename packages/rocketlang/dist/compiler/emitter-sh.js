/**
 * RocketLang Shell Emitter
 *
 * Compiles RocketLang AST to Shell (Bash) scripts.
 * Useful for simple automation and scripting tasks.
 *
 * Note: Shell has limitations - no objects, limited arrays,
 * no async. Complex programs should target JavaScript.
 */
/**
 * Shell Emitter
 */
export class ShellEmitter {
    config;
    output = [];
    warnings = [];
    indentLevel = 0;
    constructor(config = {}) {
        this.config = {
            interpreter: config.interpreter || '/bin/bash',
            strictMode: config.strictMode ?? true,
            debug: config.debug ?? false,
        };
    }
    /**
     * Emit a program
     */
    emit(program) {
        this.output = [];
        this.warnings = [];
        this.indentLevel = 0;
        // Shebang
        this.output.push(`#!${this.config.interpreter}`);
        this.output.push('');
        // Header comment
        this.output.push('# Generated by RocketLang Compiler');
        this.output.push(`# Source: ${program.sourceFile || 'unknown'}`);
        this.output.push('');
        // Strict mode
        if (this.config.strictMode) {
            this.output.push('set -euo pipefail');
            this.output.push('');
        }
        // Helper functions
        this.emitHelpers();
        this.output.push('');
        // Emit statements
        for (const stmt of program.body) {
            const code = this.emitStatement(stmt);
            if (code) {
                this.output.push(code);
            }
        }
        return {
            code: this.output.join('\n'),
            warnings: this.warnings,
        };
    }
    /**
     * Emit helper functions
     */
    emitHelpers() {
        this.output.push('# Helper functions');
        // Print function
        this.output.push('print() {');
        this.output.push('  echo "$@"');
        this.output.push('}');
        this.output.push('');
        // JSON-like output (simple)
        this.output.push('to_json() {');
        this.output.push('  echo "{\\"value\\": \\"$1\\"}"');
        this.output.push('}');
    }
    /**
     * Emit a statement
     */
    emitStatement(stmt) {
        switch (stmt.type) {
            case 'VariableDeclaration':
                return this.emitVariableDeclaration(stmt);
            case 'FunctionDeclaration':
                return this.emitFunctionDeclaration(stmt);
            case 'IfStatement':
                return this.emitIfStatement(stmt);
            case 'ForStatement':
                return this.emitForStatement(stmt);
            case 'WhileStatement':
                return this.emitWhileStatement(stmt);
            case 'ReturnStatement':
                return this.emitReturnStatement(stmt);
            case 'ExpressionStatement':
                return this.emitExpressionStatement(stmt);
            default:
                this.warnings.push(`Unsupported statement type for Shell: ${stmt.type}`);
                return `# Unsupported: ${stmt.type}`;
        }
    }
    /**
     * Emit variable declaration
     */
    emitVariableDeclaration(stmt) {
        const name = stmt.name;
        const value = this.emitExpression(stmt.value);
        if (stmt.kind === 'const') {
            return `${this.indent()}readonly ${name}=${value}`;
        }
        return `${this.indent()}${name}=${value}`;
    }
    /**
     * Emit function declaration
     */
    emitFunctionDeclaration(stmt) {
        if (stmt.async) {
            this.warnings.push(`Async functions not supported in Shell: ${stmt.name}`);
        }
        const lines = [];
        lines.push(`${this.indent()}${stmt.name}() {`);
        this.indentLevel++;
        // Parameter handling
        for (let i = 0; i < stmt.params.length; i++) {
            lines.push(`${this.indent()}local ${stmt.params[i].name}="$${i + 1}"`);
        }
        if (stmt.params.length > 0) {
            lines.push('');
        }
        for (const bodyStmt of stmt.body) {
            lines.push(this.emitStatement(bodyStmt));
        }
        this.indentLevel--;
        lines.push(`${this.indent()}}`);
        return lines.join('\n');
    }
    /**
     * Emit if statement
     */
    emitIfStatement(stmt) {
        const lines = [];
        const condition = this.emitCondition(stmt.condition);
        lines.push(`${this.indent()}if ${condition}; then`);
        this.indentLevel++;
        for (const bodyStmt of stmt.consequent) {
            lines.push(this.emitStatement(bodyStmt));
        }
        this.indentLevel--;
        if (stmt.alternate) {
            if (Array.isArray(stmt.alternate)) {
                lines.push(`${this.indent()}else`);
                this.indentLevel++;
                for (const bodyStmt of stmt.alternate) {
                    lines.push(this.emitStatement(bodyStmt));
                }
                this.indentLevel--;
            }
            else {
                // else if
                const elseIf = this.emitIfStatement(stmt.alternate);
                lines.push(`${this.indent()}el${elseIf.trimStart()}`);
                return lines.join('\n');
            }
        }
        lines.push(`${this.indent()}fi`);
        return lines.join('\n');
    }
    /**
     * Emit for statement
     */
    emitForStatement(stmt) {
        const lines = [];
        const iterable = this.emitExpression(stmt.iterable);
        lines.push(`${this.indent()}for ${stmt.variable} in ${iterable}; do`);
        this.indentLevel++;
        for (const bodyStmt of stmt.body) {
            lines.push(this.emitStatement(bodyStmt));
        }
        this.indentLevel--;
        lines.push(`${this.indent()}done`);
        return lines.join('\n');
    }
    /**
     * Emit while statement
     */
    emitWhileStatement(stmt) {
        const lines = [];
        const condition = this.emitCondition(stmt.condition);
        lines.push(`${this.indent()}while ${condition}; do`);
        this.indentLevel++;
        for (const bodyStmt of stmt.body) {
            lines.push(this.emitStatement(bodyStmt));
        }
        this.indentLevel--;
        lines.push(`${this.indent()}done`);
        return lines.join('\n');
    }
    /**
     * Emit return statement
     */
    emitReturnStatement(stmt) {
        if (stmt.value) {
            // In shell, we echo the return value and use return for exit code
            const value = this.emitExpression(stmt.value);
            return `${this.indent()}echo ${value}\n${this.indent()}return 0`;
        }
        return `${this.indent()}return 0`;
    }
    /**
     * Emit expression statement
     */
    emitExpressionStatement(stmt) {
        return `${this.indent()}${this.emitExpression(stmt.expression)}`;
    }
    /**
     * Emit a condition for if/while
     */
    emitCondition(expr) {
        if (expr.type === 'BinaryExpression') {
            const left = this.emitExpression(expr.left);
            const right = this.emitExpression(expr.right);
            // Map operators to shell test syntax
            const operatorMap = {
                '==': '-eq',
                '!=': '-ne',
                '<': '-lt',
                '>': '-gt',
                '<=': '-le',
                '>=': '-ge',
                '===': '=',
                '!==': '!=',
            };
            const op = operatorMap[expr.operator] || expr.operator;
            // String comparison vs numeric
            if (op === '=' || op === '!=') {
                return `[ "${left}" ${op} "${right}" ]`;
            }
            return `[ "${left}" ${op} "${right}" ]`;
        }
        return `[ -n "${this.emitExpression(expr)}" ]`;
    }
    /**
     * Emit an expression
     */
    emitExpression(expr) {
        switch (expr.type) {
            case 'Literal':
                return this.emitLiteral(expr);
            case 'Identifier':
                return this.emitIdentifier(expr);
            case 'BinaryExpression':
                return this.emitBinaryExpression(expr);
            case 'CallExpression':
                return this.emitCallExpression(expr);
            case 'ArrayExpression':
                return this.emitArrayExpression(expr);
            default:
                this.warnings.push(`Unsupported expression type for Shell: ${expr.type}`);
                return `"# Unsupported: ${expr.type}"`;
        }
    }
    /**
     * Emit literal
     */
    emitLiteral(expr) {
        if (typeof expr.value === 'string') {
            // Escape special characters
            const escaped = expr.value.replace(/"/g, '\\"').replace(/\$/g, '\\$');
            return `"${escaped}"`;
        }
        if (expr.value === null) {
            return '""';
        }
        if (typeof expr.value === 'boolean') {
            return expr.value ? '1' : '0';
        }
        return String(expr.value);
    }
    /**
     * Emit identifier
     */
    emitIdentifier(expr) {
        return `"$${expr.name}"`;
    }
    /**
     * Emit binary expression
     */
    emitBinaryExpression(expr) {
        const left = this.emitExpression(expr.left);
        const right = this.emitExpression(expr.right);
        // Arithmetic in shell
        if (['+', '-', '*', '/', '%'].includes(expr.operator)) {
            return `$((${left.replace(/"/g, '')} ${expr.operator} ${right.replace(/"/g, '')}))`;
        }
        // String concatenation
        if (expr.operator === '+') {
            return `"${left.replace(/"/g, '')}${right.replace(/"/g, '')}"`;
        }
        return `${left} ${expr.operator} ${right}`;
    }
    /**
     * Emit call expression
     */
    emitCallExpression(expr) {
        if (expr.callee.type !== 'Identifier') {
            this.warnings.push('Complex function calls not fully supported in Shell');
            return '# Complex call';
        }
        const name = expr.callee.name;
        const args = expr.arguments.map(a => this.emitExpression(a)).join(' ');
        // Map common functions to shell commands
        const commandMap = {
            print: 'echo',
            read_file: 'cat',
            write_file: 'tee',
            list_dir: 'ls',
            exists: 'test -e',
            mkdir: 'mkdir -p',
            rm: 'rm',
            cp: 'cp',
            mv: 'mv',
            curl: 'curl -s',
            fetch: 'curl -s',
            sleep: 'sleep',
        };
        const cmd = commandMap[name] || name;
        return `${cmd} ${args}`;
    }
    /**
     * Emit array expression
     */
    emitArrayExpression(expr) {
        const elements = expr.elements.map(e => this.emitExpression(e)).join(' ');
        return `(${elements})`;
    }
    /**
     * Get current indentation
     */
    indent() {
        return '  '.repeat(this.indentLevel);
    }
}
/**
 * Create a Shell emitter
 */
export function createShellEmitter(config) {
    return new ShellEmitter(config);
}
/**
 * Emit program to Shell script
 */
export function emitShell(program, config) {
    const emitter = createShellEmitter(config);
    return emitter.emit(program);
}
export default {
    ShellEmitter,
    createShellEmitter,
    emitShell,
};
//# sourceMappingURL=emitter-sh.js.map