/**
 * RocketLang Shell Emitter
 *
 * Compiles RocketLang AST to Shell (Bash) scripts.
 * Useful for simple automation and scripting tasks.
 *
 * Note: Shell has limitations - no objects, limited arrays,
 * no async. Complex programs should target JavaScript.
 */

import type {
  Program,
  Statement,
  Expression,
  VariableDeclaration,
  FunctionDeclaration,
  IfStatement,
  ForStatement,
  WhileStatement,
  ReturnStatement,
  ExpressionStatement,
  Literal,
  Identifier,
  BinaryExpression,
  CallExpression,
  ArrayExpression,
} from './ast.js';

/**
 * Shell emitter configuration
 */
export interface ShellEmitterConfig {
  /** Shell interpreter (default: /bin/bash) */
  interpreter?: string;
  /** Enable strict mode (set -euo pipefail) */
  strictMode?: boolean;
  /** Add comments for debugging */
  debug?: boolean;
}

/**
 * Emit result
 */
export interface ShellEmitResult {
  code: string;
  warnings: string[];
}

/**
 * Shell Emitter
 */
export class ShellEmitter {
  private config: ShellEmitterConfig;
  private output: string[] = [];
  private warnings: string[] = [];
  private indentLevel: number = 0;

  constructor(config: Partial<ShellEmitterConfig> = {}) {
    this.config = {
      interpreter: config.interpreter || '/bin/bash',
      strictMode: config.strictMode ?? true,
      debug: config.debug ?? false,
    };
  }

  /**
   * Emit a program
   */
  emit(program: Program): ShellEmitResult {
    this.output = [];
    this.warnings = [];
    this.indentLevel = 0;

    // Shebang
    this.output.push(`#!${this.config.interpreter}`);
    this.output.push('');

    // Header comment
    this.output.push('# Generated by RocketLang Compiler');
    this.output.push(`# Source: ${program.sourceFile || 'unknown'}`);
    this.output.push('');

    // Strict mode
    if (this.config.strictMode) {
      this.output.push('set -euo pipefail');
      this.output.push('');
    }

    // Helper functions
    this.emitHelpers();
    this.output.push('');

    // Emit statements
    for (const stmt of program.body) {
      const code = this.emitStatement(stmt);
      if (code) {
        this.output.push(code);
      }
    }

    return {
      code: this.output.join('\n'),
      warnings: this.warnings,
    };
  }

  /**
   * Emit helper functions
   */
  private emitHelpers(): void {
    this.output.push('# Helper functions');

    // Print function
    this.output.push('print() {');
    this.output.push('  echo "$@"');
    this.output.push('}');
    this.output.push('');

    // JSON-like output (simple)
    this.output.push('to_json() {');
    this.output.push('  echo "{\\"value\\": \\"$1\\"}"');
    this.output.push('}');
  }

  /**
   * Emit a statement
   */
  private emitStatement(stmt: Statement): string {
    switch (stmt.type) {
      case 'VariableDeclaration':
        return this.emitVariableDeclaration(stmt);
      case 'FunctionDeclaration':
        return this.emitFunctionDeclaration(stmt);
      case 'IfStatement':
        return this.emitIfStatement(stmt);
      case 'ForStatement':
        return this.emitForStatement(stmt);
      case 'WhileStatement':
        return this.emitWhileStatement(stmt);
      case 'ReturnStatement':
        return this.emitReturnStatement(stmt);
      case 'ExpressionStatement':
        return this.emitExpressionStatement(stmt);
      default:
        this.warnings.push(`Unsupported statement type for Shell: ${stmt.type}`);
        return `# Unsupported: ${stmt.type}`;
    }
  }

  /**
   * Emit variable declaration
   */
  private emitVariableDeclaration(stmt: VariableDeclaration): string {
    const name = stmt.name;
    const value = this.emitExpression(stmt.value);

    if (stmt.kind === 'const') {
      return `${this.indent()}readonly ${name}=${value}`;
    }
    return `${this.indent()}${name}=${value}`;
  }

  /**
   * Emit function declaration
   */
  private emitFunctionDeclaration(stmt: FunctionDeclaration): string {
    if (stmt.async) {
      this.warnings.push(`Async functions not supported in Shell: ${stmt.name}`);
    }

    const lines: string[] = [];
    lines.push(`${this.indent()}${stmt.name}() {`);

    this.indentLevel++;

    // Parameter handling
    for (let i = 0; i < stmt.params.length; i++) {
      lines.push(`${this.indent()}local ${stmt.params[i].name}="$${i + 1}"`);
    }

    if (stmt.params.length > 0) {
      lines.push('');
    }

    for (const bodyStmt of stmt.body) {
      lines.push(this.emitStatement(bodyStmt));
    }

    this.indentLevel--;
    lines.push(`${this.indent()}}`);

    return lines.join('\n');
  }

  /**
   * Emit if statement
   */
  private emitIfStatement(stmt: IfStatement): string {
    const lines: string[] = [];
    const condition = this.emitCondition(stmt.condition);

    lines.push(`${this.indent()}if ${condition}; then`);

    this.indentLevel++;
    for (const bodyStmt of stmt.consequent) {
      lines.push(this.emitStatement(bodyStmt));
    }
    this.indentLevel--;

    if (stmt.alternate) {
      if (Array.isArray(stmt.alternate)) {
        lines.push(`${this.indent()}else`);
        this.indentLevel++;
        for (const bodyStmt of stmt.alternate) {
          lines.push(this.emitStatement(bodyStmt));
        }
        this.indentLevel--;
      } else {
        // else if
        const elseIf = this.emitIfStatement(stmt.alternate);
        lines.push(`${this.indent()}el${elseIf.trimStart()}`);
        return lines.join('\n');
      }
    }

    lines.push(`${this.indent()}fi`);
    return lines.join('\n');
  }

  /**
   * Emit for statement
   */
  private emitForStatement(stmt: ForStatement): string {
    const lines: string[] = [];
    const iterable = this.emitExpression(stmt.iterable);

    lines.push(`${this.indent()}for ${stmt.variable} in ${iterable}; do`);

    this.indentLevel++;
    for (const bodyStmt of stmt.body) {
      lines.push(this.emitStatement(bodyStmt));
    }
    this.indentLevel--;

    lines.push(`${this.indent()}done`);
    return lines.join('\n');
  }

  /**
   * Emit while statement
   */
  private emitWhileStatement(stmt: WhileStatement): string {
    const lines: string[] = [];
    const condition = this.emitCondition(stmt.condition);

    lines.push(`${this.indent()}while ${condition}; do`);

    this.indentLevel++;
    for (const bodyStmt of stmt.body) {
      lines.push(this.emitStatement(bodyStmt));
    }
    this.indentLevel--;

    lines.push(`${this.indent()}done`);
    return lines.join('\n');
  }

  /**
   * Emit return statement
   */
  private emitReturnStatement(stmt: ReturnStatement): string {
    if (stmt.value) {
      // In shell, we echo the return value and use return for exit code
      const value = this.emitExpression(stmt.value);
      return `${this.indent()}echo ${value}\n${this.indent()}return 0`;
    }
    return `${this.indent()}return 0`;
  }

  /**
   * Emit expression statement
   */
  private emitExpressionStatement(stmt: ExpressionStatement): string {
    return `${this.indent()}${this.emitExpression(stmt.expression)}`;
  }

  /**
   * Emit a condition for if/while
   */
  private emitCondition(expr: Expression): string {
    if (expr.type === 'BinaryExpression') {
      const left = this.emitExpression(expr.left);
      const right = this.emitExpression(expr.right);

      // Map operators to shell test syntax
      const operatorMap: Record<string, string> = {
        '==': '-eq',
        '!=': '-ne',
        '<': '-lt',
        '>': '-gt',
        '<=': '-le',
        '>=': '-ge',
        '===': '=',
        '!==': '!=',
      };

      const op = operatorMap[expr.operator] || expr.operator;

      // String comparison vs numeric
      if (op === '=' || op === '!=') {
        return `[ "${left}" ${op} "${right}" ]`;
      }

      return `[ "${left}" ${op} "${right}" ]`;
    }

    return `[ -n "${this.emitExpression(expr)}" ]`;
  }

  /**
   * Emit an expression
   */
  private emitExpression(expr: Expression): string {
    switch (expr.type) {
      case 'Literal':
        return this.emitLiteral(expr);
      case 'Identifier':
        return this.emitIdentifier(expr);
      case 'BinaryExpression':
        return this.emitBinaryExpression(expr);
      case 'CallExpression':
        return this.emitCallExpression(expr);
      case 'ArrayExpression':
        return this.emitArrayExpression(expr);
      default:
        this.warnings.push(`Unsupported expression type for Shell: ${expr.type}`);
        return `"# Unsupported: ${expr.type}"`;
    }
  }

  /**
   * Emit literal
   */
  private emitLiteral(expr: Literal): string {
    if (typeof expr.value === 'string') {
      // Escape special characters
      const escaped = expr.value.replace(/"/g, '\\"').replace(/\$/g, '\\$');
      return `"${escaped}"`;
    }
    if (expr.value === null) {
      return '""';
    }
    if (typeof expr.value === 'boolean') {
      return expr.value ? '1' : '0';
    }
    return String(expr.value);
  }

  /**
   * Emit identifier
   */
  private emitIdentifier(expr: Identifier): string {
    return `"$${expr.name}"`;
  }

  /**
   * Emit binary expression
   */
  private emitBinaryExpression(expr: BinaryExpression): string {
    const left = this.emitExpression(expr.left);
    const right = this.emitExpression(expr.right);

    // Arithmetic in shell
    if (['+', '-', '*', '/', '%'].includes(expr.operator)) {
      return `$((${left.replace(/"/g, '')} ${expr.operator} ${right.replace(/"/g, '')}))`;
    }

    // String concatenation
    if (expr.operator === '+') {
      return `"${left.replace(/"/g, '')}${right.replace(/"/g, '')}"`;
    }

    return `${left} ${expr.operator} ${right}`;
  }

  /**
   * Emit call expression
   */
  private emitCallExpression(expr: CallExpression): string {
    if (expr.callee.type !== 'Identifier') {
      this.warnings.push('Complex function calls not fully supported in Shell');
      return '# Complex call';
    }

    const name = expr.callee.name;
    const args = expr.arguments.map(a => this.emitExpression(a)).join(' ');

    // Map common functions to shell commands
    const commandMap: Record<string, string> = {
      print: 'echo',
      read_file: 'cat',
      write_file: 'tee',
      list_dir: 'ls',
      exists: 'test -e',
      mkdir: 'mkdir -p',
      rm: 'rm',
      cp: 'cp',
      mv: 'mv',
      curl: 'curl -s',
      fetch: 'curl -s',
      sleep: 'sleep',
    };

    const cmd = commandMap[name] || name;
    return `${cmd} ${args}`;
  }

  /**
   * Emit array expression
   */
  private emitArrayExpression(expr: ArrayExpression): string {
    const elements = expr.elements.map(e => this.emitExpression(e)).join(' ');
    return `(${elements})`;
  }

  /**
   * Get current indentation
   */
  private indent(): string {
    return '  '.repeat(this.indentLevel);
  }
}

/**
 * Create a Shell emitter
 */
export function createShellEmitter(config?: Partial<ShellEmitterConfig>): ShellEmitter {
  return new ShellEmitter(config);
}

/**
 * Emit program to Shell script
 */
export function emitShell(program: Program, config?: Partial<ShellEmitterConfig>): ShellEmitResult {
  const emitter = createShellEmitter(config);
  return emitter.emit(program);
}

export default {
  ShellEmitter,
  createShellEmitter,
  emitShell,
};
